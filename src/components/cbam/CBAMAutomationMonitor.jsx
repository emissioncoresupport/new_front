import { useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { base44 } from '@/api/base44Client';
import { toast } from "sonner";
import { getCurrentCompany } from '@/components/utils/multiTenant';

/**
 * Background automation monitor for CBAM certificate purchasing
 * Runs checks when emission entries or certificates change
 */
export default function CBAMAutomationMonitor({ entries, certificates, purchaseOrders }) {
  const queryClient = useQueryClient();

  const { data: company } = useQuery({
    queryKey: ['current-company'],
    queryFn: getCurrentCompany
  });

  const { data: settings } = useQuery({
    queryKey: ['cbam-automation-settings', company?.id],
    queryFn: async () => {
      const allSettings = await base44.entities.CBAMAutomationSettings.list();
      return allSettings.find(s => s.company_id === company?.id);
    },
    enabled: !!company
  });

  const { data: priceHistory = [] } = useQuery({
    queryKey: ['cbam-price-history'],
    queryFn: () => base44.entities.CBAMPriceHistory.list('-date', 1)
  });

  const createOrderMutation = useMutation({
    mutationFn: async ({ quantity, estimatedPrice, autoApprove }) => {
      const orderData = {
        company_id: company?.id,
        order_number: `PO-AUTO-${new Date().getFullYear()}-${Math.floor(Math.random() * 10000)}`,
        quantity,
        estimated_price: estimatedPrice,
        total_amount: quantity * estimatedPrice,
        order_date: new Date().toISOString().split('T')[0],
        status: autoApprove ? 'approved' : 'pending_approval',
        supplier: "EU CBAM Registry",
        notes: `Auto-generated by CBAM automation system. ${autoApprove ? 'Auto-approved.' : 'Pending manual approval.'}`
      };

      return base44.entities.CBAMPurchaseOrder.create(orderData);
    },
    onSuccess: (order, variables) => {
      queryClient.invalidateQueries({ queryKey: ['cbam-purchase-orders'] });
      
      if (variables.autoApprove) {
        toast.success('Auto-approved certificate purchase', {
          description: `${variables.quantity} certificates for €${(variables.quantity * variables.estimatedPrice).toLocaleString()}`
        });
      } else {
        toast.info('Draft purchase order created', {
          description: `${variables.quantity} certificates pending approval`
        });
      }

      // Send notification if configured
      if (settings?.notification_email) {
        base44.integrations.Core.SendEmail({
          to: settings.notification_email,
          subject: `CBAM: ${variables.autoApprove ? 'Auto-Approved' : 'Draft'} Order Created`,
          body: `A ${variables.autoApprove ? 'purchase order has been automatically approved' : 'draft purchase order has been created'} for ${variables.quantity} CBAM certificates.\n\nOrder: ${order.order_number}\nTotal: €${(variables.quantity * variables.estimatedPrice).toLocaleString()}\nStatus: ${order.status}\n\nView in CBAM Financial Hub.`
        }).catch(err => console.error('Failed to send notification email:', err));
      }
    }
  });

  const updateSettingsMutation = useMutation({
    mutationFn: (data) => base44.entities.CBAMAutomationSettings.update(settings.id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['cbam-automation-settings'] });
    }
  });

  useEffect(() => {
    if (!settings?.auto_generate_orders || !company) return;

    // Calculate shortfall
    const companyEntries = entries.filter(e => e.company_id === company.id);
    const companyCertificates = certificates.filter(c => c.company_id === company.id);
    const companyOrders = purchaseOrders.filter(o => o.company_id === company.id);

    const totalEmissions = companyEntries.reduce((acc, curr) => acc + (curr.total_embedded_emissions || 0), 0);
    const cbamRate2026 = 0.025;
    const requiredCertificates = Math.ceil(totalEmissions * cbamRate2026);
    
    const currentBalance = companyCertificates
      .filter(c => c.status === 'active')
      .reduce((acc, curr) => acc + (curr.quantity || 0), 0);
    
    const pendingQuantity = companyOrders
      .filter(o => ['draft', 'pending_approval', 'approved'].includes(o.status))
      .reduce((acc, curr) => acc + (curr.quantity || 0), 0);

    const shortfall = requiredCertificates - (currentBalance + pendingQuantity);

    // Check if we should trigger auto-order
    if (shortfall >= settings.shortfall_threshold) {
      // Add buffer
      const bufferMultiplier = 1 + (settings.buffer_percentage / 100);
      const orderQuantity = Math.ceil(shortfall * bufferMultiplier);

      // Get current price
      const currentPrice = priceHistory[0]?.cbam_certificate_price || 88;
      const totalCost = orderQuantity * currentPrice;

      // Check if we should auto-approve
      const shouldAutoApprove = settings.auto_approve_enabled && totalCost <= settings.auto_approve_limit;

      // Prevent duplicate orders (check if auto-order was created in last 24 hours)
      const lastOrderTime = settings.last_auto_order_date ? new Date(settings.last_auto_order_date) : null;
      const hoursSinceLastOrder = lastOrderTime ? (Date.now() - lastOrderTime.getTime()) / (1000 * 60 * 60) : 999;

      if (hoursSinceLastOrder > 24) {
        createOrderMutation.mutate({
          quantity: orderQuantity,
          estimatedPrice: currentPrice,
          autoApprove: shouldAutoApprove
        });

        // Update last auto-order timestamp
        updateSettingsMutation.mutate({
          last_auto_order_date: new Date().toISOString()
        });
      }
    }
  }, [entries, certificates, purchaseOrders, settings, company]);

  return null; // This is a background component
}